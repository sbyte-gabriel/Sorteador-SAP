{
  "_entries": [
    {
      "name": "js-confetti",
      "path": "C:\\Users\\t.gabriel\\node_modules\\js-confetti\\dist\\es\\index.js",
      "lastModified": 1755875154128,
      "type": "module",
      "originalName": "index",
      "code": "sap.ui.define((function () { 'use strict';\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    return Constructor;\n  }\n\n  function normalizeComputedStyleValue(string) {\n    // \"250px\" --> 250\n    return +string.replace(/px/, '');\n  }\n\n  function fixDPR(canvas) {\n    var dpr = window.devicePixelRatio;\n    var computedStyles = getComputedStyle(canvas);\n    var width = normalizeComputedStyleValue(computedStyles.getPropertyValue('width'));\n    var height = normalizeComputedStyleValue(computedStyles.getPropertyValue('height'));\n    canvas.setAttribute('width', (width * dpr).toString());\n    canvas.setAttribute('height', (height * dpr).toString());\n  }\n\n  function generateRandomNumber(min, max) {\n    var fractionDigits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var randomNumber = Math.random() * (max - min) + min;\n    return Math.floor(randomNumber * Math.pow(10, fractionDigits)) / Math.pow(10, fractionDigits);\n  }\n\n  function generateRandomArrayElement(arr) {\n    return arr[generateRandomNumber(0, arr.length)];\n  }\n\n  var FREE_FALLING_OBJECT_ACCELERATION = 0.00125;\n  var MIN_DRAG_FORCE_COEFFICIENT = 0.0005;\n  var MAX_DRAG_FORCE_COEFFICIENT = 0.0009;\n  var ROTATION_SLOWDOWN_ACCELERATION = 0.00001;\n  var INITIAL_SHAPE_RADIUS = 6;\n  var INITIAL_EMOJI_SIZE = 80;\n  var MIN_INITIAL_CONFETTI_SPEED = 0.9;\n  var MAX_INITIAL_CONFETTI_SPEED = 1.7;\n  var MIN_FINAL_X_CONFETTI_SPEED = 0.2;\n  var MAX_FINAL_X_CONFETTI_SPEED = 0.6;\n  var MIN_INITIAL_ROTATION_SPEED = 0.03;\n  var MAX_INITIAL_ROTATION_SPEED = 0.07;\n  var MIN_CONFETTI_ANGLE = 15;\n  var MAX_CONFETTI_ANGLE = 82;\n  var SHAPE_VISIBILITY_TRESHOLD = 100;\n  var DEFAULT_CONFETTI_NUMBER = 250;\n  var DEFAULT_EMOJIS_NUMBER = 40;\n  var DEFAULT_CONFETTI_COLORS = ['#fcf403', '#62fc03', '#f4fc03', '#03e7fc', '#03fca5', '#a503fc', '#fc03ad', '#fc03c2'];\n\n  function getWindowWidthCoefficient(canvasWidth) {\n    var HD_SCREEN_WIDTH = 1920;\n    return Math.log(canvasWidth) / Math.log(HD_SCREEN_WIDTH);\n  }\n\n  var ConfettiShape = /*#__PURE__*/function () {\n    function ConfettiShape(args) {\n      _classCallCheck(this, ConfettiShape);\n\n      var initialPosition = args.initialPosition,\n          direction = args.direction,\n          confettiRadius = args.confettiRadius,\n          confettiColors = args.confettiColors,\n          emojis = args.emojis,\n          emojiSize = args.emojiSize,\n          canvasWidth = args.canvasWidth;\n      var randomConfettiSpeed = generateRandomNumber(MIN_INITIAL_CONFETTI_SPEED, MAX_INITIAL_CONFETTI_SPEED, 3);\n      var initialSpeed = randomConfettiSpeed * getWindowWidthCoefficient(canvasWidth);\n      this.confettiSpeed = {\n        x: initialSpeed,\n        y: initialSpeed\n      };\n      this.finalConfettiSpeedX = generateRandomNumber(MIN_FINAL_X_CONFETTI_SPEED, MAX_FINAL_X_CONFETTI_SPEED, 3);\n      this.rotationSpeed = emojis.length ? 0.01 : generateRandomNumber(MIN_INITIAL_ROTATION_SPEED, MAX_INITIAL_ROTATION_SPEED, 3) * getWindowWidthCoefficient(canvasWidth);\n      this.dragForceCoefficient = generateRandomNumber(MIN_DRAG_FORCE_COEFFICIENT, MAX_DRAG_FORCE_COEFFICIENT, 6);\n      this.radius = {\n        x: confettiRadius,\n        y: confettiRadius\n      };\n      this.initialRadius = confettiRadius;\n      this.rotationAngle = direction === 'left' ? generateRandomNumber(0, 0.2, 3) : generateRandomNumber(-0.2, 0, 3);\n      this.emojiSize = emojiSize;\n      this.emojiRotationAngle = generateRandomNumber(0, 2 * Math.PI);\n      this.radiusYUpdateDirection = 'down';\n      var angle = direction === 'left' ? generateRandomNumber(MAX_CONFETTI_ANGLE, MIN_CONFETTI_ANGLE) * Math.PI / 180 : generateRandomNumber(-MIN_CONFETTI_ANGLE, -MAX_CONFETTI_ANGLE) * Math.PI / 180;\n      this.absCos = Math.abs(Math.cos(angle));\n      this.absSin = Math.abs(Math.sin(angle));\n      var positionShift = generateRandomNumber(-150, 0);\n      var shiftedInitialPosition = {\n        x: initialPosition.x + (direction === 'left' ? -positionShift : positionShift) * this.absCos,\n        y: initialPosition.y - positionShift * this.absSin\n      };\n      this.currentPosition = Object.assign({}, shiftedInitialPosition);\n      this.initialPosition = Object.assign({}, shiftedInitialPosition);\n      this.color = emojis.length ? null : generateRandomArrayElement(confettiColors);\n      this.emoji = emojis.length ? generateRandomArrayElement(emojis) : null;\n      this.createdAt = new Date().getTime();\n      this.direction = direction;\n    }\n\n    _createClass(ConfettiShape, [{\n      key: \"draw\",\n      value: function draw(canvasContext) {\n        var currentPosition = this.currentPosition,\n            radius = this.radius,\n            color = this.color,\n            emoji = this.emoji,\n            rotationAngle = this.rotationAngle,\n            emojiRotationAngle = this.emojiRotationAngle,\n            emojiSize = this.emojiSize;\n        var dpr = window.devicePixelRatio;\n\n        if (color) {\n          canvasContext.fillStyle = color;\n          canvasContext.beginPath();\n          canvasContext.ellipse(currentPosition.x * dpr, currentPosition.y * dpr, radius.x * dpr, radius.y * dpr, rotationAngle, 0, 2 * Math.PI);\n          canvasContext.fill();\n        } else if (emoji) {\n          canvasContext.font = \"\".concat(emojiSize, \"px serif\");\n          canvasContext.save();\n          canvasContext.translate(dpr * currentPosition.x, dpr * currentPosition.y);\n          canvasContext.rotate(emojiRotationAngle);\n          canvasContext.textAlign = 'center';\n          canvasContext.fillText(emoji, 0, 0);\n          canvasContext.restore();\n        }\n      }\n    }, {\n      key: \"updatePosition\",\n      value: function updatePosition(iterationTimeDelta, currentTime) {\n        var confettiSpeed = this.confettiSpeed,\n            dragForceCoefficient = this.dragForceCoefficient,\n            finalConfettiSpeedX = this.finalConfettiSpeedX,\n            radiusYUpdateDirection = this.radiusYUpdateDirection,\n            rotationSpeed = this.rotationSpeed,\n            createdAt = this.createdAt,\n            direction = this.direction;\n        var timeDeltaSinceCreation = currentTime - createdAt;\n        if (confettiSpeed.x > finalConfettiSpeedX) this.confettiSpeed.x -= dragForceCoefficient * iterationTimeDelta;\n        this.currentPosition.x += confettiSpeed.x * (direction === 'left' ? -this.absCos : this.absCos) * iterationTimeDelta;\n        this.currentPosition.y = this.initialPosition.y - confettiSpeed.y * this.absSin * timeDeltaSinceCreation + FREE_FALLING_OBJECT_ACCELERATION * Math.pow(timeDeltaSinceCreation, 2) / 2;\n        this.rotationSpeed -= this.emoji ? 0.0001 : ROTATION_SLOWDOWN_ACCELERATION * iterationTimeDelta;\n        if (this.rotationSpeed < 0) this.rotationSpeed = 0; // no need to update rotation radius for emoji\n\n        if (this.emoji) {\n          this.emojiRotationAngle += this.rotationSpeed * iterationTimeDelta % (2 * Math.PI);\n          return;\n        }\n\n        if (radiusYUpdateDirection === 'down') {\n          this.radius.y -= iterationTimeDelta * rotationSpeed;\n\n          if (this.radius.y <= 0) {\n            this.radius.y = 0;\n            this.radiusYUpdateDirection = 'up';\n          }\n        } else {\n          this.radius.y += iterationTimeDelta * rotationSpeed;\n\n          if (this.radius.y >= this.initialRadius) {\n            this.radius.y = this.initialRadius;\n            this.radiusYUpdateDirection = 'down';\n          }\n        }\n      }\n    }, {\n      key: \"getIsVisibleOnCanvas\",\n      value: function getIsVisibleOnCanvas(canvasHeight) {\n        return this.currentPosition.y < canvasHeight + SHAPE_VISIBILITY_TRESHOLD;\n      }\n    }]);\n\n    return ConfettiShape;\n  }();\n\n  function createCanvas() {\n    var canvas = document.createElement('canvas');\n    canvas.style.position = 'fixed';\n    canvas.style.width = '100%';\n    canvas.style.height = '100%';\n    canvas.style.top = '0';\n    canvas.style.left = '0';\n    canvas.style.zIndex = '1000';\n    canvas.style.pointerEvents = 'none';\n    document.body.appendChild(canvas);\n    return canvas;\n  }\n\n  function normalizeConfettiConfig(confettiConfig) {\n    var _confettiConfig$confe = confettiConfig.confettiRadius,\n        confettiRadius = _confettiConfig$confe === void 0 ? INITIAL_SHAPE_RADIUS : _confettiConfig$confe,\n        _confettiConfig$confe2 = confettiConfig.confettiNumber,\n        confettiNumber = _confettiConfig$confe2 === void 0 ? confettiConfig.confettiesNumber || (confettiConfig.emojis ? DEFAULT_EMOJIS_NUMBER : DEFAULT_CONFETTI_NUMBER) : _confettiConfig$confe2,\n        _confettiConfig$confe3 = confettiConfig.confettiColors,\n        confettiColors = _confettiConfig$confe3 === void 0 ? DEFAULT_CONFETTI_COLORS : _confettiConfig$confe3,\n        _confettiConfig$emoji = confettiConfig.emojis,\n        emojis = _confettiConfig$emoji === void 0 ? confettiConfig.emojies || [] : _confettiConfig$emoji,\n        _confettiConfig$emoji2 = confettiConfig.emojiSize,\n        emojiSize = _confettiConfig$emoji2 === void 0 ? INITIAL_EMOJI_SIZE : _confettiConfig$emoji2; // deprecate wrong plural forms, used in early releases\n\n    if (confettiConfig.emojies) console.error(\"emojies argument is deprecated, please use emojis instead\");\n    if (confettiConfig.confettiesNumber) console.error(\"confettiesNumber argument is deprecated, please use confettiNumber instead\");\n    return {\n      confettiRadius: confettiRadius,\n      confettiNumber: confettiNumber,\n      confettiColors: confettiColors,\n      emojis: emojis,\n      emojiSize: emojiSize\n    };\n  }\n\n  var ConfettiBatch = /*#__PURE__*/function () {\n    function ConfettiBatch(canvasContext) {\n      var _this = this;\n\n      _classCallCheck(this, ConfettiBatch);\n\n      this.canvasContext = canvasContext;\n      this.shapes = [];\n      this.promise = new Promise(function (completionCallback) {\n        return _this.resolvePromise = completionCallback;\n      });\n    }\n\n    _createClass(ConfettiBatch, [{\n      key: \"getBatchCompletePromise\",\n      value: function getBatchCompletePromise() {\n        return this.promise;\n      }\n    }, {\n      key: \"addShapes\",\n      value: function addShapes() {\n        var _this$shapes;\n\n        (_this$shapes = this.shapes).push.apply(_this$shapes, arguments);\n      }\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        var _a;\n\n        if (this.shapes.length) {\n          return false;\n        }\n\n        (_a = this.resolvePromise) === null || _a === void 0 ? void 0 : _a.call(this);\n        return true;\n      }\n    }, {\n      key: \"processShapes\",\n      value: function processShapes(time, canvasHeight, cleanupInvisibleShapes) {\n        var _this2 = this;\n\n        var timeDelta = time.timeDelta,\n            currentTime = time.currentTime;\n        this.shapes = this.shapes.filter(function (shape) {\n          // Render the shapes in this batch\n          shape.updatePosition(timeDelta, currentTime);\n          shape.draw(_this2.canvasContext); // Only cleanup the shapes if we're being asked to\n\n          if (!cleanupInvisibleShapes) {\n            return true;\n          }\n\n          return shape.getIsVisibleOnCanvas(canvasHeight);\n        });\n      }\n    }]);\n\n    return ConfettiBatch;\n  }();\n\n  var JSConfetti = /*#__PURE__*/function () {\n    function JSConfetti() {\n      var jsConfettiConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      _classCallCheck(this, JSConfetti);\n\n      this.activeConfettiBatches = [];\n      this.canvas = jsConfettiConfig.canvas || createCanvas();\n      this.canvasContext = this.canvas.getContext('2d');\n      this.requestAnimationFrameRequested = false;\n      this.lastUpdated = new Date().getTime();\n      this.iterationIndex = 0;\n      this.loop = this.loop.bind(this);\n      requestAnimationFrame(this.loop);\n    }\n\n    _createClass(JSConfetti, [{\n      key: \"loop\",\n      value: function loop() {\n        this.requestAnimationFrameRequested = false;\n        fixDPR(this.canvas);\n        var currentTime = new Date().getTime();\n        var timeDelta = currentTime - this.lastUpdated;\n        var canvasHeight = this.canvas.offsetHeight;\n        var cleanupInvisibleShapes = this.iterationIndex % 10 === 0;\n        this.activeConfettiBatches = this.activeConfettiBatches.filter(function (batch) {\n          batch.processShapes({\n            timeDelta: timeDelta,\n            currentTime: currentTime\n          }, canvasHeight, cleanupInvisibleShapes); // Do not remove invisible shapes on every iteration\n\n          if (!cleanupInvisibleShapes) {\n            return true;\n          }\n\n          return !batch.complete();\n        });\n        this.iterationIndex++;\n        this.queueAnimationFrameIfNeeded(currentTime);\n      }\n    }, {\n      key: \"queueAnimationFrameIfNeeded\",\n      value: function queueAnimationFrameIfNeeded(currentTime) {\n        if (this.requestAnimationFrameRequested) {\n          // We already have a pended animation frame, so there is no more work\n          return;\n        }\n\n        if (this.activeConfettiBatches.length < 1) {\n          // No shapes to animate, so don't queue another frame\n          return;\n        }\n\n        this.requestAnimationFrameRequested = true; // Capture the last updated time for animation\n\n        this.lastUpdated = currentTime || new Date().getTime();\n        requestAnimationFrame(this.loop);\n      }\n    }, {\n      key: \"addConfetti\",\n      value: function addConfetti() {\n        var confettiConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        var _normalizeConfettiCon = normalizeConfettiConfig(confettiConfig),\n            confettiRadius = _normalizeConfettiCon.confettiRadius,\n            confettiNumber = _normalizeConfettiCon.confettiNumber,\n            confettiColors = _normalizeConfettiCon.confettiColors,\n            emojis = _normalizeConfettiCon.emojis,\n            emojiSize = _normalizeConfettiCon.emojiSize; // Use the bounding rect rather tahn the canvas width / height, because\n        // .width / .height are unset until a layout pass has been completed. Upon\n        // confetti being immediately queued on a page load, this hasn't happened so\n        // the default of 300x150 will be returned, causing an improper source point\n        // for the confetti animation.\n\n\n        var canvasRect = this.canvas.getBoundingClientRect();\n        var canvasWidth = canvasRect.width;\n        var canvasHeight = canvasRect.height;\n        var yPosition = canvasHeight * 5 / 7;\n        var leftConfettiPosition = {\n          x: 0,\n          y: yPosition\n        };\n        var rightConfettiPosition = {\n          x: canvasWidth,\n          y: yPosition\n        };\n        var confettiGroup = new ConfettiBatch(this.canvasContext);\n\n        for (var i = 0; i < confettiNumber / 2; i++) {\n          var confettiOnTheRight = new ConfettiShape({\n            initialPosition: leftConfettiPosition,\n            direction: 'right',\n            confettiRadius: confettiRadius,\n            confettiColors: confettiColors,\n            confettiNumber: confettiNumber,\n            emojis: emojis,\n            emojiSize: emojiSize,\n            canvasWidth: canvasWidth\n          });\n          var confettiOnTheLeft = new ConfettiShape({\n            initialPosition: rightConfettiPosition,\n            direction: 'left',\n            confettiRadius: confettiRadius,\n            confettiColors: confettiColors,\n            confettiNumber: confettiNumber,\n            emojis: emojis,\n            emojiSize: emojiSize,\n            canvasWidth: canvasWidth\n          });\n          confettiGroup.addShapes(confettiOnTheRight, confettiOnTheLeft);\n        }\n\n        this.activeConfettiBatches.push(confettiGroup);\n        this.queueAnimationFrameIfNeeded();\n        return confettiGroup.getBatchCompletePromise();\n      }\n    }, {\n      key: \"clearCanvas\",\n      value: function clearCanvas() {\n        this.activeConfettiBatches = [];\n      }\n    }, {\n      key: \"destroyCanvas\",\n      value: function destroyCanvas() {\n        this.canvas.remove();\n      }\n    }]);\n\n    return JSConfetti;\n  }();\n\n  var namedExports = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    default: JSConfetti\n  });\n\n  const defaultExports = Object.isFrozen(JSConfetti) ? Object.assign({}, JSConfetti?.default || JSConfetti || { __emptyModule: true }) : JSConfetti;\n  Object.keys(namedExports || {}).filter((key) => !defaultExports[key]).forEach((key) => defaultExports[key] = namedExports[key]);\n  Object.defineProperty(defaultExports, \"__\" + \"esModule\", { value: true });\n  var index = Object.isFrozen(JSConfetti) ? Object.freeze(defaultExports) : defaultExports;\n\n  return index;\n\n}));\n",
      "relatedPaths": [
        "C:\\Users\\t.gabriel\\node_modules\\js-confetti\\dist\\es\\index.js"
      ],
      "imports": [],
      "dynamicImports": [],
      "generated": false,
      "isWebComponent": false,
      "isEntryPoint": true
    }
  ]
}