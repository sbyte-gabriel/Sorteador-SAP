{
  "_entries": [
    {
      "name": "js-confetti",
      "path": "C:\\projetos\\Sorteador\\Sorteador-SAP\\zui_sorteador\\node_modules\\js-confetti\\dist\\es\\index.js",
      "lastModified": 1758896739702,
      "type": "module",
      "originalName": "index",
      "code": "sap.ui.define((function () { 'use strict';\n\n  function _classCallCheck(a, n) {\n    if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n  function _defineProperties(e, r) {\n    for (var t = 0; t < r.length; t++) {\n      var o = r[t];\n      o.enumerable = o.enumerable || false, o.configurable = true, \"value\" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);\n    }\n  }\n  function _createClass(e, r, t) {\n    return r && _defineProperties(e.prototype, r), Object.defineProperty(e, \"prototype\", {\n      writable: false\n    }), e;\n  }\n  function _toPrimitive(t, r) {\n    if (\"object\" != typeof t || !t) return t;\n    var e = t[Symbol.toPrimitive];\n    if (void 0 !== e) {\n      var i = e.call(t, r);\n      if (\"object\" != typeof i) return i;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (String )(t);\n  }\n  function _toPropertyKey(t) {\n    var i = _toPrimitive(t, \"string\");\n    return \"symbol\" == typeof i ? i : i + \"\";\n  }\n\n  function normalizeComputedStyleValue(string) {\n    // \"250px\" --> 250\n    return +string.replace(/px/, '');\n  }\n  function fixDPR(canvas) {\n    var dpr = window.devicePixelRatio;\n    var computedStyles = getComputedStyle(canvas);\n    var width = normalizeComputedStyleValue(computedStyles.getPropertyValue('width'));\n    var height = normalizeComputedStyleValue(computedStyles.getPropertyValue('height'));\n    canvas.setAttribute('width', (width * dpr).toString());\n    canvas.setAttribute('height', (height * dpr).toString());\n  }\n\n  function generateRandomNumber(min, max) {\n    var fractionDigits = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var randomNumber = Math.random() * (max - min) + min;\n    return Math.floor(randomNumber * Math.pow(10, fractionDigits)) / Math.pow(10, fractionDigits);\n  }\n\n  function generateRandomArrayElement(arr) {\n    return arr[generateRandomNumber(0, arr.length)];\n  }\n\n  var FREE_FALLING_OBJECT_ACCELERATION = 0.00125;\n  var MIN_DRAG_FORCE_COEFFICIENT = 0.0005;\n  var MAX_DRAG_FORCE_COEFFICIENT = 0.0009;\n  var ROTATION_SLOWDOWN_ACCELERATION = 0.00001;\n  var INITIAL_SHAPE_RADIUS = 6;\n  var INITIAL_EMOJI_SIZE = 80;\n  var MIN_INITIAL_CONFETTI_SPEED = 0.9;\n  var MAX_INITIAL_CONFETTI_SPEED = 1.7;\n  var MIN_FINAL_X_CONFETTI_SPEED = 0.2;\n  var MAX_FINAL_X_CONFETTI_SPEED = 0.6;\n  var MIN_INITIAL_ROTATION_SPEED = 0.03;\n  var MAX_INITIAL_ROTATION_SPEED = 0.07;\n  var MIN_CONFETTI_ANGLE_IN_DEGREES = 15;\n  var MAX_CONFETTI_ANGLE_IN_DEGREES = 82;\n  var MAX_CONFETTI_ANGLE_FIRED_FROM_SPEICIFIED_POSITION_IN_DEGREES = 150;\n  var SHAPE_VISIBILITY_TRESHOLD = 100;\n  var DEFAULT_CONFETTI_NUMBER = 250;\n  var DEFAULT_EMOJIS_NUMBER = 40;\n  var DEFAULT_CONFETTI_COLORS = ['#fcf403', '#62fc03', '#f4fc03', '#03e7fc', '#03fca5', '#a503fc', '#fc03ad', '#fc03c2'];\n\n  // For wide screens - fast confetti, for small screens - slow confetti\n  function getWindowWidthCoefficient(canvasWidth) {\n    var HD_SCREEN_WIDTH = 1920;\n    return Math.log(canvasWidth) / Math.log(HD_SCREEN_WIDTH);\n  }\n  var ConfettiShape = /*#__PURE__*/function () {\n    function ConfettiShape(args) {\n      _classCallCheck(this, ConfettiShape);\n      var initialPosition = args.initialPosition,\n        confettiRadius = args.confettiRadius,\n        confettiColors = args.confettiColors,\n        emojis = args.emojis,\n        emojiSize = args.emojiSize,\n        canvasWidth = args.canvasWidth,\n        initialFlightAngle = args.initialFlightAngle,\n        rotationAngle = args.rotationAngle,\n        _args$shouldHideConfe = args.shouldHideConfettiInShiftedPosition,\n        shouldHideConfettiInShiftedPosition = _args$shouldHideConfe === void 0 ? false : _args$shouldHideConfe;\n      var randomConfettiSpeed = generateRandomNumber(MIN_INITIAL_CONFETTI_SPEED, MAX_INITIAL_CONFETTI_SPEED, 3);\n      var initialSpeed = randomConfettiSpeed * getWindowWidthCoefficient(canvasWidth);\n      this.confettiSpeed = {\n        x: initialSpeed,\n        y: initialSpeed\n      };\n      this.finalConfettiSpeedX = generateRandomNumber(MIN_FINAL_X_CONFETTI_SPEED, MAX_FINAL_X_CONFETTI_SPEED, 3);\n      this.rotationSpeed = emojis.length ? 0.01 : generateRandomNumber(MIN_INITIAL_ROTATION_SPEED, MAX_INITIAL_ROTATION_SPEED, 3) * getWindowWidthCoefficient(canvasWidth);\n      this.dragForceCoefficient = generateRandomNumber(MIN_DRAG_FORCE_COEFFICIENT, MAX_DRAG_FORCE_COEFFICIENT, 6);\n      this.radius = {\n        x: confettiRadius,\n        y: confettiRadius\n      };\n      this.initialRadius = confettiRadius;\n      this.rotationAngle = rotationAngle;\n      this.emojiSize = emojiSize;\n      this.emojiRotationAngle = generateRandomNumber(0, 2 * Math.PI);\n      this.radiusYUpdateDirection = 'down';\n      this.cos = Math.cos(initialFlightAngle);\n      this.sin = Math.sin(initialFlightAngle);\n      var positionShift = generateRandomNumber(-150, 0);\n      this.positionOffset = {\n        x: positionShift * this.sin,\n        y: positionShift * this.cos\n      };\n      this.distanceTravelled = {\n        x: 0,\n        y: 0\n      };\n      var shiftedInitialPosition = {\n        x: initialPosition.x + this.positionOffset.x,\n        y: initialPosition.y - this.positionOffset.y\n      };\n      this.currentPosition = Object.assign({}, shiftedInitialPosition);\n      this.initialPosition = Object.assign({}, shiftedInitialPosition);\n      this.color = emojis.length ? null : generateRandomArrayElement(confettiColors);\n      this.emoji = emojis.length ? generateRandomArrayElement(emojis) : null;\n      this.createdAt = new Date().getTime();\n      this.isVisible = !shouldHideConfettiInShiftedPosition;\n    }\n    return _createClass(ConfettiShape, [{\n      key: \"draw\",\n      value: function draw(canvasContext) {\n        var currentPosition = this.currentPosition,\n          radius = this.radius,\n          color = this.color,\n          emoji = this.emoji,\n          rotationAngle = this.rotationAngle,\n          emojiRotationAngle = this.emojiRotationAngle,\n          emojiSize = this.emojiSize,\n          isVisible = this.isVisible;\n        if (!isVisible) return;\n        var dpr = window.devicePixelRatio;\n        if (color) {\n          canvasContext.fillStyle = color;\n          canvasContext.beginPath();\n          canvasContext.ellipse(currentPosition.x * dpr, currentPosition.y * dpr, radius.x * dpr, radius.y * dpr, rotationAngle, 0, 2 * Math.PI);\n          canvasContext.fill();\n        } else if (emoji) {\n          canvasContext.font = \"\".concat(emojiSize, \"px serif\");\n          canvasContext.save();\n          canvasContext.translate(dpr * currentPosition.x, dpr * currentPosition.y);\n          canvasContext.rotate(emojiRotationAngle);\n          canvasContext.textAlign = 'center';\n          canvasContext.fillText(emoji, 0, 0);\n          canvasContext.restore();\n        }\n      }\n    }, {\n      key: \"updatePosition\",\n      value: function updatePosition(iterationTimeDelta, currentTime) {\n        var confettiSpeed = this.confettiSpeed,\n          dragForceCoefficient = this.dragForceCoefficient,\n          finalConfettiSpeedX = this.finalConfettiSpeedX,\n          radiusYUpdateDirection = this.radiusYUpdateDirection,\n          rotationSpeed = this.rotationSpeed,\n          createdAt = this.createdAt;\n        if (confettiSpeed.x > finalConfettiSpeedX) this.confettiSpeed.x -= dragForceCoefficient * iterationTimeDelta;\n        var prevPositionY = this.currentPosition.y;\n        var timeDeltaSinceCreation = currentTime - createdAt;\n        this.currentPosition.y = this.initialPosition.y - confettiSpeed.y * this.cos * timeDeltaSinceCreation + FREE_FALLING_OBJECT_ACCELERATION * Math.pow(timeDeltaSinceCreation, 2) / 2;\n        var positionUpdate = {\n          x: confettiSpeed.x * this.sin * iterationTimeDelta,\n          y: this.currentPosition.y - prevPositionY\n        };\n        this.currentPosition.x += positionUpdate.x;\n        this.distanceTravelled.x += Math.abs(positionUpdate.x);\n        this.distanceTravelled.y += Math.abs(positionUpdate.y);\n        if (this.distanceTravelled.x >= Math.abs(this.positionOffset.x) && this.distanceTravelled.y >= Math.abs(this.positionOffset.y)) {\n          this.isVisible = true;\n        }\n        this.rotationSpeed -= this.emoji ? 0.0001 : ROTATION_SLOWDOWN_ACCELERATION * iterationTimeDelta;\n        if (this.rotationSpeed < 0) this.rotationSpeed = 0;\n        // no need to update rotation radius for emoji\n        if (this.emoji) {\n          this.emojiRotationAngle += this.rotationSpeed * iterationTimeDelta % (2 * Math.PI);\n          return;\n        }\n        if (radiusYUpdateDirection === 'down') {\n          this.radius.y -= iterationTimeDelta * rotationSpeed;\n          if (this.radius.y <= 0) {\n            this.radius.y = 0;\n            this.radiusYUpdateDirection = 'up';\n          }\n        } else {\n          this.radius.y += iterationTimeDelta * rotationSpeed;\n          if (this.radius.y >= this.initialRadius) {\n            this.radius.y = this.initialRadius;\n            this.radiusYUpdateDirection = 'down';\n          }\n        }\n      }\n    }, {\n      key: \"getIsVisibleOnCanvas\",\n      value: function getIsVisibleOnCanvas(canvasHeight) {\n        return this.currentPosition.y < canvasHeight + SHAPE_VISIBILITY_TRESHOLD;\n      }\n    }]);\n  }();\n\n  function createCanvas() {\n    var canvas = document.createElement('canvas');\n    canvas.style.position = 'fixed';\n    canvas.style.width = '100%';\n    canvas.style.height = '100%';\n    canvas.style.top = '0';\n    canvas.style.left = '0';\n    canvas.style.zIndex = '1000';\n    canvas.style.pointerEvents = 'none';\n    document.body.appendChild(canvas);\n    return canvas;\n  }\n\n  function normalizeConfettiConfig(confettiConfig) {\n    var _confettiConfig$confe = confettiConfig.confettiRadius,\n      confettiRadius = _confettiConfig$confe === void 0 ? INITIAL_SHAPE_RADIUS : _confettiConfig$confe,\n      _confettiConfig$confe2 = confettiConfig.confettiNumber,\n      confettiNumber = _confettiConfig$confe2 === void 0 ? confettiConfig.confettiesNumber || (confettiConfig.emojis ? DEFAULT_EMOJIS_NUMBER : DEFAULT_CONFETTI_NUMBER) : _confettiConfig$confe2,\n      _confettiConfig$confe3 = confettiConfig.confettiColors,\n      confettiColors = _confettiConfig$confe3 === void 0 ? DEFAULT_CONFETTI_COLORS : _confettiConfig$confe3,\n      _confettiConfig$emoji = confettiConfig.emojis,\n      emojis = _confettiConfig$emoji === void 0 ? confettiConfig.emojies || [] : _confettiConfig$emoji,\n      _confettiConfig$emoji2 = confettiConfig.emojiSize,\n      emojiSize = _confettiConfig$emoji2 === void 0 ? INITIAL_EMOJI_SIZE : _confettiConfig$emoji2,\n      _confettiConfig$confe4 = confettiConfig.confettiDispatchPosition,\n      confettiDispatchPosition = _confettiConfig$confe4 === void 0 ? null : _confettiConfig$confe4;\n    // deprecate wrong plural forms, used in early releases\n    if (confettiConfig.emojies) console.error(\"emojies argument is deprecated, please use emojis instead\");\n    if (confettiConfig.confettiesNumber) console.error(\"confettiesNumber argument is deprecated, please use confettiNumber instead\");\n    return {\n      confettiRadius: confettiRadius,\n      confettiNumber: confettiNumber,\n      confettiColors: confettiColors,\n      emojis: emojis,\n      emojiSize: emojiSize,\n      confettiDispatchPosition: confettiDispatchPosition\n    };\n  }\n\n  function convertDegreesToRadians(degreesToRadians) {\n    return degreesToRadians * Math.PI / 180;\n  }\n  /*\n   * determine the angle at which confetti is being dispatched\n   *\n   * for confetti that are dispatched from the sides of the screen, there's a min and max angle at which they could fly\n   * for confetti that are dispatched from the specific position (like mouse click), the angle ranges from -max to max\n   *\n   * the angle is stored in radians, but degrees are used in constants for convenience\n   *\n   * examples:\n   * - 0 means that confetti would fly straight up\n   * - 0.7 means that confetti would start flying approximately 40 degrees to the right\n   */\n  function generateConfettiInitialFlightAngleFiredFromLeftSideOfTheScreen() {\n    return convertDegreesToRadians(generateRandomNumber(MAX_CONFETTI_ANGLE_IN_DEGREES, MIN_CONFETTI_ANGLE_IN_DEGREES));\n  }\n  function generateConfettiInitialFlightAngleFiredFromRightSideOfTheScreen() {\n    return convertDegreesToRadians(generateRandomNumber(-MIN_CONFETTI_ANGLE_IN_DEGREES, -MAX_CONFETTI_ANGLE_IN_DEGREES));\n  }\n  function generateConfettiInitialFlightAngleFiredFromSpecificPosition() {\n    return convertDegreesToRadians(generateRandomNumber(-MAX_CONFETTI_ANGLE_FIRED_FROM_SPEICIFIED_POSITION_IN_DEGREES, MAX_CONFETTI_ANGLE_FIRED_FROM_SPEICIFIED_POSITION_IN_DEGREES));\n  }\n  /*\n   * WHAT IS THIS?\n   */\n  function generateConfettiRotationAngleFiredFromLeftSideOfTheScreen() {\n    return generateRandomNumber(0, 0.2, 3);\n  }\n  function generateConfettiRotationAngleFiredFromRightSideOfTheScreen() {\n    return generateRandomNumber(-0.2, 0, 3);\n  }\n\n  var ConfettiBatch = /*#__PURE__*/function () {\n    function ConfettiBatch(canvasContext) {\n      var _this = this;\n      _classCallCheck(this, ConfettiBatch);\n      this.canvasContext = canvasContext;\n      this.shapes = [];\n      this.promise = new Promise(function (completionCallback) {\n        return _this.resolvePromise = completionCallback;\n      });\n    }\n    return _createClass(ConfettiBatch, [{\n      key: \"getBatchCompletePromise\",\n      value: function getBatchCompletePromise() {\n        return this.promise;\n      }\n    }, {\n      key: \"addShapes\",\n      value: function addShapes() {\n        var _this$shapes;\n        (_this$shapes = this.shapes).push.apply(_this$shapes, arguments);\n      }\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        var _a;\n        if (this.shapes.length) {\n          return false;\n        }\n        (_a = this.resolvePromise) === null || _a === void 0 ? void 0 : _a.call(this);\n        return true;\n      }\n    }, {\n      key: \"processShapes\",\n      value: function processShapes(time, canvasHeight, cleanupInvisibleShapes) {\n        var _this2 = this;\n        var timeDelta = time.timeDelta,\n          currentTime = time.currentTime;\n        this.shapes = this.shapes.filter(function (shape) {\n          // Render the shapes in this batch\n          shape.updatePosition(timeDelta, currentTime);\n          shape.draw(_this2.canvasContext);\n          // Only cleanup the shapes if we're being asked to\n          if (!cleanupInvisibleShapes) {\n            return true;\n          }\n          return shape.getIsVisibleOnCanvas(canvasHeight);\n        });\n      }\n    }]);\n  }();\n  var JSConfetti = /*#__PURE__*/function () {\n    function JSConfetti() {\n      var jsConfettiConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      _classCallCheck(this, JSConfetti);\n      this.activeConfettiBatches = [];\n      this.canvas = jsConfettiConfig.canvas || createCanvas();\n      this.canvasContext = this.canvas.getContext('2d');\n      this.requestAnimationFrameRequested = false;\n      this.lastUpdated = new Date().getTime();\n      this.iterationIndex = 0;\n      this.loop = this.loop.bind(this);\n      requestAnimationFrame(this.loop);\n    }\n    return _createClass(JSConfetti, [{\n      key: \"loop\",\n      value: function loop() {\n        this.requestAnimationFrameRequested = false;\n        fixDPR(this.canvas);\n        var currentTime = new Date().getTime();\n        var timeDelta = currentTime - this.lastUpdated;\n        var canvasHeight = this.canvas.offsetHeight;\n        var cleanupInvisibleShapes = this.iterationIndex % 10 === 0;\n        this.activeConfettiBatches = this.activeConfettiBatches.filter(function (batch) {\n          batch.processShapes({\n            timeDelta: timeDelta,\n            currentTime: currentTime\n          }, canvasHeight, cleanupInvisibleShapes);\n          // Do not remove invisible shapes on every iteration\n          if (!cleanupInvisibleShapes) {\n            return true;\n          }\n          return !batch.complete();\n        });\n        this.iterationIndex++;\n        this.queueAnimationFrameIfNeeded(currentTime);\n      }\n    }, {\n      key: \"queueAnimationFrameIfNeeded\",\n      value: function queueAnimationFrameIfNeeded(currentTime) {\n        if (this.requestAnimationFrameRequested) {\n          // We already have a pended animation frame, so there is no more work\n          return;\n        }\n        if (this.activeConfettiBatches.length < 1) {\n          // No shapes to animate, so don't queue another frame\n          return;\n        }\n        this.requestAnimationFrameRequested = true;\n        // Capture the last updated time for animation\n        this.lastUpdated = currentTime || new Date().getTime();\n        requestAnimationFrame(this.loop);\n      }\n    }, {\n      key: \"addConfettiAtPosition\",\n      value: function addConfettiAtPosition() {\n        var confettiConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var _normalizeConfettiCon = normalizeConfettiConfig(confettiConfig),\n          confettiRadius = _normalizeConfettiCon.confettiRadius,\n          confettiNumber = _normalizeConfettiCon.confettiNumber,\n          confettiColors = _normalizeConfettiCon.confettiColors,\n          emojis = _normalizeConfettiCon.emojis,\n          emojiSize = _normalizeConfettiCon.emojiSize,\n          confettiDispatchPosition = _normalizeConfettiCon.confettiDispatchPosition;\n        var _this$canvas$getBound = this.canvas.getBoundingClientRect(),\n          canvasWidth = _this$canvas$getBound.width;\n        var confettiGroup = new ConfettiBatch(this.canvasContext);\n        for (var i = 0; i < confettiNumber; i++) {\n          var confettiShape = new ConfettiShape({\n            initialPosition: confettiDispatchPosition,\n            confettiRadius: confettiRadius,\n            confettiColors: confettiColors,\n            confettiNumber: confettiNumber,\n            emojis: emojis,\n            emojiSize: emojiSize,\n            canvasWidth: canvasWidth,\n            rotationAngle: generateConfettiRotationAngleFiredFromLeftSideOfTheScreen(),\n            initialFlightAngle: generateConfettiInitialFlightAngleFiredFromSpecificPosition(),\n            shouldHideConfettiInShiftedPosition: true\n          });\n          confettiGroup.addShapes(confettiShape);\n        }\n        this.activeConfettiBatches.push(confettiGroup);\n        this.queueAnimationFrameIfNeeded();\n        return confettiGroup.getBatchCompletePromise();\n      }\n    }, {\n      key: \"addConfetti\",\n      value: function addConfetti() {\n        var confettiConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var _normalizeConfettiCon2 = normalizeConfettiConfig(confettiConfig),\n          confettiRadius = _normalizeConfettiCon2.confettiRadius,\n          confettiNumber = _normalizeConfettiCon2.confettiNumber,\n          confettiColors = _normalizeConfettiCon2.confettiColors,\n          emojis = _normalizeConfettiCon2.emojis,\n          emojiSize = _normalizeConfettiCon2.emojiSize;\n        // Use the bounding rect rather tahn the canvas width / height, because\n        // .width / .height are unset until a layout pass has been completed. Upon\n        // confetti being immediately queued on a page load, this hasn't happened so\n        // the default of 300x150 will be returned, causing an improper source point\n        // for the confetti animation.\n        var _this$canvas$getBound2 = this.canvas.getBoundingClientRect(),\n          canvasWidth = _this$canvas$getBound2.width,\n          canvasHeight = _this$canvas$getBound2.height;\n        var yPosition = canvasHeight * 5 / 7;\n        var leftConfettiPosition = {\n          x: 0,\n          y: yPosition\n        };\n        var rightConfettiPosition = {\n          x: canvasWidth,\n          y: yPosition\n        };\n        var confettiGroup = new ConfettiBatch(this.canvasContext);\n        for (var i = 0; i < confettiNumber / 2; i++) {\n          var confettiOnTheLeft = new ConfettiShape({\n            initialPosition: leftConfettiPosition,\n            confettiRadius: confettiRadius,\n            confettiColors: confettiColors,\n            confettiNumber: confettiNumber,\n            emojis: emojis,\n            emojiSize: emojiSize,\n            canvasWidth: canvasWidth,\n            rotationAngle: generateConfettiRotationAngleFiredFromLeftSideOfTheScreen(),\n            initialFlightAngle: generateConfettiInitialFlightAngleFiredFromLeftSideOfTheScreen()\n          });\n          var confettiOnTheRight = new ConfettiShape({\n            initialPosition: rightConfettiPosition,\n            confettiRadius: confettiRadius,\n            confettiColors: confettiColors,\n            confettiNumber: confettiNumber,\n            emojis: emojis,\n            emojiSize: emojiSize,\n            canvasWidth: canvasWidth,\n            rotationAngle: generateConfettiRotationAngleFiredFromRightSideOfTheScreen(),\n            initialFlightAngle: generateConfettiInitialFlightAngleFiredFromRightSideOfTheScreen()\n          });\n          confettiGroup.addShapes(confettiOnTheRight, confettiOnTheLeft);\n        }\n        this.activeConfettiBatches.push(confettiGroup);\n        this.queueAnimationFrameIfNeeded();\n        return confettiGroup.getBatchCompletePromise();\n      }\n    }, {\n      key: \"clearCanvas\",\n      value: function clearCanvas() {\n        this.activeConfettiBatches = [];\n      }\n    }, {\n      key: \"destroyCanvas\",\n      value: function destroyCanvas() {\n        this.canvas.remove();\n      }\n    }]);\n  }();\n\n  var namedExports = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    default: JSConfetti\n  });\n\n  const defaultExports = Object.isFrozen(JSConfetti) ? Object.assign({}, JSConfetti?.default || JSConfetti || { __emptyModule: true }) : JSConfetti;\n  Object.keys(namedExports || {}).filter((key) => !defaultExports[key]).forEach((key) => defaultExports[key] = namedExports[key]);\n  Object.defineProperty(defaultExports, \"__\" + \"esModule\", { value: true });\n  var index = Object.isFrozen(JSConfetti) ? Object.freeze(defaultExports) : defaultExports;\n\n  return index;\n\n}));\n",
      "relatedPaths": [
        "C:\\projetos\\Sorteador\\Sorteador-SAP\\zui_sorteador\\node_modules\\js-confetti\\dist\\es\\index.js"
      ],
      "imports": [],
      "dynamicImports": [],
      "generated": false,
      "isWebComponent": false,
      "isEntryPoint": true
    }
  ]
}